use ast::{
    expr,
    lit::{self, LitInt},
    stmt,
};
use ir::{constant::*, stmt::*, *};

pub struct LoweringContext {
    body: Body,

    block_at: BlockId,
}

impl LoweringContext {
    pub fn new() -> Self {
        LoweringContext {
            body: Body::new(),
            block_at: BlockId::dummy(),
        }
    }

    pub fn build(self) -> Body {
        self.body
    }

    pub fn lower_stmt(&mut self, stmt: &stmt::Stmt) {
        match stmt {
            stmt::Stmt::Expr(expr) => {
                // the value that generated by lowering expr is assign to local of return value
                self.block_at = self.body.blocks.push_and_get_key(Block::new());

                let operand = self.lower_expr(expr);
                let rvalue = RValue::Use(operand);
                let place = self.body.local_return();
                let statement = Statement::Assign(Box::new((place, rvalue)));
                self.body.blocks[self.block_at].stmts.push(statement);
            }
        }
    }

    pub fn lower_expr(&mut self, expr: &expr::Expr) -> Operand {
        match expr {
            expr::Expr::Binary(expr) => self.lower_expr_binary(expr),
            expr::Expr::Unary(_) => todo!(),
            expr::Expr::Lit(lit) => self.lower_expr_lit(lit),
        }
    }

    fn lower_expr_binary(&mut self, expr: &expr::ExprBinary) -> Operand {
        let lhs = self.lower_expr(&expr.lhs);
        let rhs = self.lower_expr(&expr.rhs);

        let op = match expr.op {
            ast::op::BinOp::Add => BinOp::Add,
            ast::op::BinOp::Sub => BinOp::Sub,
            ast::op::BinOp::Mul => BinOp::Mul,
            ast::op::BinOp::Div => BinOp::Div,
        };

        let rvalue = RValue::BinaryOp(op, Box::new((lhs, rhs)));
        let place = self.push_unnamed_local();
        let statement = Statement::Assign(Box::new((place.clone(), rvalue)));

        self.body.blocks[self.block_at].stmts.push(statement);

        Operand::Copy(place)
    }

    fn lower_expr_lit(&mut self, expr: &expr::ExprLit) -> Operand {
        match &expr.lit {
            lit::Lit::Int(LitInt { digits }) => {
                let data: u128 = digits.parse().unwrap();
                let constant = Constant::Scalar(ScalarInt {
                    data: data,
                    size: 32,
                });
                Operand::Constant(Box::new(constant))
            }
        }
    }

    fn push_unnamed_local(&mut self) -> Place {
        let local_decl = LocalDecl::unnamed();
        let id = self.body.local_decls.push_and_get_key(local_decl);

        Place::new(id)
    }
}
