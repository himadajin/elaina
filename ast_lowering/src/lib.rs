use ast::{
    block,
    expr::{self, Ident},
    lit::{self, LitInt},
    stmt,
};
use ir::{constant::*, stmt::*, *};

use std::collections::HashMap;

pub struct LoweringContext {
    body: Body,

    block_at: BlockId,

    local_name_table: HashMap<String, Place>,
}

impl LoweringContext {
    pub fn new() -> Self {
        LoweringContext {
            body: Body::new(),
            block_at: BlockId::dummy(),
            local_name_table: HashMap::new(),
        }
    }

    pub fn build(self) -> Body {
        self.body
    }

    pub fn lower_main_block(&mut self, block: &block::Block) {
        self.block_at = self.body.blocks.push_and_get_key(Block::new());

        for stmt in &block.stmts {
            self.lower_stmt(stmt);
        }
    }

    pub fn lower_stmt(&mut self, stmt: &stmt::Stmt) {
        match stmt {
            stmt::Stmt::Local(local) => {
                let place = {
                    let name = local.ident.clone();
                    self.push_named_local(name)
                };
                let rvalue = {
                    let init = self.lower_expr(&local.init);
                    RValue::Use(init)
                };

                let statement = Statement::Assign(Box::new((place, rvalue)));
                self.body.blocks[self.block_at].stmts.push(statement);
            }
            stmt::Stmt::Expr(expr) => {
                // the value that generated by lowering expr is assign to local of return value
                let place = self.body.local_return();

                let rvalue = {
                    let operand = self.lower_expr(expr);
                    RValue::Use(operand)
                };

                let statement = Statement::Assign(Box::new((place, rvalue)));
                self.body.blocks[self.block_at].stmts.push(statement);
            }
            stmt::Stmt::Semi(_) => todo!(),
        }
    }

    pub fn lower_expr(&mut self, expr: &expr::Expr) -> Operand {
        match expr {
            expr::Expr::Binary(expr) => self.lower_expr_binary(expr),
            expr::Expr::Unary(_) => todo!(),
            expr::Expr::Lit(lit) => self.lower_expr_lit(lit),
            expr::Expr::Ident(ident) => self.lower_expr_ident(ident),
        }
    }

    fn lower_expr_binary(&mut self, expr: &expr::ExprBinary) -> Operand {
        let lhs = self.lower_expr(&expr.lhs);
        let rhs = self.lower_expr(&expr.rhs);

        let op = match expr.op {
            ast::op::BinOp::Add => BinOp::Add,
            ast::op::BinOp::Sub => BinOp::Sub,
            ast::op::BinOp::Mul => BinOp::Mul,
            ast::op::BinOp::Div => BinOp::Div,
        };

        let rvalue = RValue::BinaryOp(op, Box::new((lhs, rhs)));
        let place = self.push_unnamed_local();
        let statement = Statement::Assign(Box::new((place.clone(), rvalue)));

        self.body.blocks[self.block_at].stmts.push(statement);

        Operand::Copy(place)
    }

    fn lower_expr_lit(&mut self, expr: &expr::ExprLit) -> Operand {
        match &expr.lit {
            lit::Lit::Int(LitInt { digits }) => {
                let data: u128 = digits.parse().unwrap();
                let constant = Constant::Scalar(ScalarInt {
                    data: data,
                    size: 32,
                });
                Operand::Constant(Box::new(constant))
            }
        }
    }

    fn lower_expr_ident(&mut self, ident: &Ident) -> Operand {
        let name = &ident.ident.clone();
        let local = self.local_name_table.get(name).unwrap().clone();

        Operand::Copy(local)
    }

    fn push_unnamed_local(&mut self) -> Place {
        let local_decl = LocalDecl::unnamed();
        let id = self.body.local_decls.push_and_get_key(local_decl);

        Place::new(id)
    }

    fn push_named_local(&mut self, name: String) -> Place {
        let local_decl = LocalDecl::named(name.clone());
        let id = self.body.local_decls.push_and_get_key(local_decl);
        let place = Place::new(id);

        self.local_name_table.insert(name, place.clone());

        place
    }
}
